# ЛР8. Вариант 16
### Найти ФИО и ID клиентов с минимальным количеством расходных транзакций в заданный период времени (время с .. по..)
- `generate_file.py` – Генерирует файл `client_log`
- `client` – Типы данных, необходимые для парсинга строк
- `vector` – Реализация вектора (в себе хранит `Client`
- `solution` – Парсинг файла и фильтр клиентов под условие задачи

>[!NOTE]
> CLI нет – входные данные редактируются в `main.c` переменные `start_time` и `end_time`

---

# Отчёт по лабораторной работе №8 по курсу "Фундаментальная информатика"

**Тема:** Динамическое распределение памяти.  

**Цель:** Освоить методы работы с динамическими структурами данных в C, реализовать фильтр клиентов по заданным условиям.  

**Задание:** Найти ФИО и ID клиентов с минимальным количеством расходных транзакций в заданный период времени.


## Идея и метод решения
- Данные клиентов считываются из текстового файла построчно, с динамическим выделением памяти для строк и транзакций 
- Для хранения всех клиентов используется динамический массив указателей (`vector *clients`):
  - Основной `vector` хранит указатели на структуры `Client`
  - Каждый `Client` содержит динамический массив указателей на `Transaction`
- Для фильтрации клиентов:  
  1. Перевод строки с датой и временем в числовой `timestamp` (во время парсинга строк)
  2. Счёт количества расходных транзакций клиента в заданном интервале (во время итерирования по `clients`)
  3. Выбор клиентов с минимальным количеством расходов

## Алгоритм
### 1. Чтение данных из файла
- Последовательно считываются строки файла:
  - `pid` (целое число)
  - ФИО (три строки, разделённые табуляцией)
  - Количество транзакций `N`
  - `N` строк с данными о транзакциях
- Для каждой строки выделяется память
- Каждая транзакция парсится в структуру с числовым `timestamp`

### 2. Фильтрация (`get_solution_clients`)
- Преобразуются входные строки `start` и `end` в `long long` timestamp’ы
- Для каждого клиента:
  - Инициализируется счётчик `spent = 0`
  - Проход по всем его транзакциям:
    - Если транзакция – **расход** (`is_profit == false`) и её `timestamp` лежит в `[start_timestamp, end_timestamp]`, то `spent++`.
- Если `spent < minimal_spent`:
  - Очищается текущий результат (`not_deep_clear` — освобождает только массив указателей, но не сами объекты `Client`, так как они принадлежат исходному вектору)
  - Обновляется `minimal_spent`
  - Клиент добавляется в результат
- Если `spent == minimal_spent`, то клиент добавляется в результат.


## Сценарий выполнения работы
0. Анализ задания..
1. Написан скрипт `generate_file.py` для генерации тестового файла `client_log`
2. Проектирование структур данных: `Transaction`, `Client`, `vector`
3. Реализация модулей: `client`, `vector`, `solution`, `utils`
4. **Тестирование**:
> Используется `client_log` из репозитория

| start_time    | end_time  | Output |
|:-----------------:|:----------------:|:----------------:|
| 01.12.20 05:00:00      | 01.12.26 05:00:00     |      Всего клиентов: 30<br>Минимальное количество расходных транзакций: 1<br>Подходящих клиентов: 2<br>Зайцев Андрей Алексеевич [pid: 5]<br>Смирнов Дмитрий Александрович [pid: 6]        |
| 01.12.22 05:00:00     | 01.12.22 05:00:00      |      Всего клиентов: 30<br>Минимальное количество расходных транзакций: 0<br>Подходящих клиентов: 30<br>...        |

## Выводы

В ходе выполнения лабораторной работы была успешно реализована обработка структурированных данных с использованием динамического выделения памяти в языке C. 
- Особое внимание было уделено безопасности работы с памятью: все вызовы `malloc` сопровождались проверкой на `NULL`
- Программа спроектирована модульно — логика разнесена по независимым компонентам (`client`, `vector`, `solution`, `utils`)

Данная работа показала, что даже при отсутствии автоматического управления памятью в C можно создавать надёжные, читаемые и эффективные программы.
